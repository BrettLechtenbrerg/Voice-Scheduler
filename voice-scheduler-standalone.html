<!DOCTYPE html>
<html>
<head>
    <title>Voice Scheduler - Standalone</title>
    <style>
        body { 
            font-family: system-ui, -apple-system, sans-serif;
            max-width: 600px; 
            margin: 0 auto; 
            padding: 2rem;
            background-color: #f5f5f5;
        }
        .container { 
            background: white; 
            border-radius: 12px; 
            padding: 2rem; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        .testing-mode { 
            background: #fff3cd; 
            padding: 1.5rem; 
            border-radius: 8px; 
            margin-bottom: 2rem; 
            border: 1px solid #ffeaa7; 
        }
        .record-btn { 
            background: #4CAF50; 
            color: white; 
            border: none; 
            border-radius: 50px; 
            padding: 1rem 2rem; 
            font-size: 1.1rem; 
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(76,175,80,0.3);
        }
        .stop-btn { 
            background: #f44336; 
            color: white; 
            border: none; 
            border-radius: 50px; 
            padding: 1rem 2rem; 
            font-size: 1.1rem; 
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(244,67,54,0.3);
        }
        .error { 
            background: #ffebee; 
            color: #c62828; 
            padding: 1rem; 
            border-radius: 8px; 
            margin: 1rem 0; 
            text-align: center;
        }
        .result { 
            background: #e8f5e8; 
            padding: 1rem; 
            border-radius: 8px; 
            margin: 1rem 0;
            border: 1px solid #c3e6c3;
        }
        .transcription { 
            background: #f8f9fa; 
            padding: 1rem; 
            border-radius: 8px; 
            margin: 1rem 0;
            border: 1px solid #e9ecef;
        }
        input[type="password"] {
            width: 100%; 
            padding: 0.75rem; 
            margin: 0.5rem 0; 
            border: 1px solid #ddd; 
            border-radius: 4px;
            box-sizing: border-box;
        }
        .tips {
            margin-top: 3rem;
            padding: 1rem;
            background-color: #f8f9fa;
            border-radius: 8px;
            font-size: 0.9rem;
            color: #666;
        }
        .success {
            background: #d4edda;
            color: #155724;
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 style="text-align: center; margin-bottom: 2rem; color: #333;">üé§ Voice Scheduler - Standalone</h1>
        <p style="text-align: center; margin-bottom: 2rem; color: #666;">
            Speak your contact information to automatically create leads and send calendar links
        </p>
        
        <div class="testing-mode">
            <h4 style="margin: 0 0 1rem 0; color: #856404;">üß™ Testing Mode</h4>
            <label style="display: block; margin-bottom: 0.5rem; font-size: 0.9rem; color: #856404;">
                OpenAI API Key (required for transcription):
            </label>
            <input type="password" id="apiKey" placeholder="sk-proj-..." style="margin-bottom: 0.5rem;">
            <p style="font-size: 0.8rem; color: #6c757d; margin: 0; font-style: italic;">
                ‚ö†Ô∏è Your API key is used directly in the browser and not stored anywhere.
            </p>
            <p id="apiStatus" style="font-size: 0.9rem; color: #856404; margin: 0.5rem 0 0 0;">
                ‚ùå No API key - transcription will fail
            </p>
        </div>
        
        <div style="text-align: center; margin: 2rem 0;">
            <button id="recordBtn" class="record-btn">üéôÔ∏è Start Recording</button>
            <button id="stopBtn" class="stop-btn" style="display: none;">‚èπÔ∏è Stop Recording</button>
            <div id="processing" style="display: none; color: #2196F3; font-size: 1.1rem; margin-top: 1rem;">üîÑ Processing audio...</div>
        </div>
        
        <div id="error" class="error" style="display: none;"></div>
        <div id="success" class="success" style="display: none;"></div>
        <div id="transcriptionResult" class="transcription" style="display: none;"></div>
        <div id="contactData" class="result" style="display: none;"></div>
        
        <div class="tips">
            <h4>üí° Tips for best results:</h4>
            <ul>
                <li>Speak clearly and at a normal pace</li>
                <li>Include "My name is..." or "This is..."</li>
                <li>Say phone numbers digit by digit</li>
                <li>Spell out email addresses if needed</li>
                <li>Mention company name if applicable</li>
            </ul>
            <p><strong>Note:</strong> This version calls OpenAI directly from your browser.</p>
        </div>
    </div>
    
    <script>
        let mediaRecorder;
        let audioChunks = [];
        let apiKey = '';
        
        document.getElementById('apiKey').addEventListener('input', (e) => {
            apiKey = e.target.value;
            document.getElementById('apiStatus').textContent = 
                apiKey ? '‚úÖ API key entered - voice transcription enabled' : '‚ùå No API key - transcription will fail';
        });
        
        document.getElementById('recordBtn').addEventListener('click', startRecording);
        document.getElementById('stopBtn').addEventListener('click', stopRecording);
        
        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    audioChunks.push(event.data);
                };
                
                mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    await processAudio(audioBlob);
                    stream.getTracks().forEach(track => track.stop());
                };
                
                mediaRecorder.start();
                document.getElementById('recordBtn').style.display = 'none';
                document.getElementById('stopBtn').style.display = 'inline-block';
                hideElement('error');
                hideElement('success');
            } catch (err) {
                showError('Failed to access microphone. Please allow microphone access.');
            }
        }
        
        function stopRecording() {
            if (mediaRecorder) {
                mediaRecorder.stop();
                document.getElementById('recordBtn').style.display = 'inline-block';
                document.getElementById('stopBtn').style.display = 'none';
                document.getElementById('processing').style.display = 'block';
            }
        }
        
        async function processAudio(audioBlob) {
            if (!apiKey) {
                showError('Please enter your OpenAI API key first.');
                document.getElementById('processing').style.display = 'none';
                return;
            }
            
            try {
                const formData = new FormData();
                formData.append('file', audioBlob, 'recording.webm');
                formData.append('model', 'whisper-1');
                formData.append('language', 'en');
                
                const response = await fetch('https://api.openai.com/v1/audio/transcriptions', {
                    method: 'POST',
                    headers: {
                        'Authorization': 'Bearer ' + apiKey,
                    },
                    body: formData,
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error?.message || 'Transcription failed');
                }
                
                const result = await response.json();
                const transcriptionText = result.text;
                
                showSuccess('‚úÖ Transcription successful!');
                showTranscription(transcriptionText);
                
                // Parse contact information
                const contactData = parseContactInfo(transcriptionText);
                showContactData(contactData);
                
            } catch (err) {
                showError('Failed to transcribe audio: ' + err.message);
            } finally {
                document.getElementById('processing').style.display = 'none';
            }
        }
        
        function parseContactInfo(transcription) {
            const result = {
                name: '',
                phone: '',
                email: '',
                company: '',
                notes: transcription,
            };

            // Extract phone numbers - handle various formats including voice patterns
            let phoneFound = false;
            
            // Pattern 1: "cell phone number is" or similar - handle digit sequences
            const cellPhoneRegex = /(?:cell phone number is|phone number is|cell phone|phone number)\s+([0-9]{3}[-.\s]*[0-9]{3}[-.\s]*[0-9]{4})/i;
            const cellPhoneMatch = transcription.match(cellPhoneRegex);
            if (cellPhoneMatch) {
                const cleanPhone = cellPhoneMatch[1].replace(/\D/g, '');
                if (cleanPhone.length === 10) {
                    result.phone = cleanPhone.substring(0,3) + '-' + cleanPhone.substring(3,6) + '-' + cleanPhone.substring(6);
                } else {
                    result.phone = cleanPhone;
                }
                phoneFound = true;
            }
            
            // Pattern 2: Standard phone number format  
            if (!phoneFound) {
                const phoneRegex = /(\+?1?[-.\s]?)?\(?([0-9]{3})\)?[-.\s]?([0-9]{3})[-.\s]?([0-9]{4})/;
                const phoneMatch = transcription.match(phoneRegex);
                if (phoneMatch) {
                    const cleanPhone = phoneMatch[0].replace(/\D/g, '');
                    if (cleanPhone.length === 10) {
                        result.phone = cleanPhone.substring(0,3) + '-' + cleanPhone.substring(3,6) + '-' + cleanPhone.substring(6);
                    } else if (cleanPhone.length === 11 && cleanPhone.startsWith('1')) {
                        // Remove leading 1 for US numbers
                        const usPhone = cleanPhone.substring(1);
                        result.phone = usPhone.substring(0,3) + '-' + usPhone.substring(3,6) + '-' + usPhone.substring(6);
                    } else {
                        result.phone = cleanPhone;
                    }
                }
            }

            // Extract email addresses - handle voice patterns better
            let emailFound = false;
            
            // Pattern 1: "email is [name] at [domain] dot com"
            const emailDotComRegex = /email is\s+([a-zA-Z0-9._%-]+)\s+at\s+([a-zA-Z0-9.\s-]+)\s+dot\s+com/i;
            const emailDotComMatch = transcription.match(emailDotComRegex);
            if (emailDotComMatch) {
                const domain = emailDotComMatch[2].replace(/\s+/g, '');
                result.email = emailDotComMatch[1] + '@' + domain + '.com';
                emailFound = true;
            }
            
            // Pattern 2: "email is" followed by email
            if (!emailFound) {
                const emailIsRegex = /(?:email is|email)\s+([a-zA-Z0-9._%-]+)\s+at\s+([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/i;
                const emailIsMatch = transcription.match(emailIsRegex);
                if (emailIsMatch) {
                    result.email = emailIsMatch[1] + '@' + emailIsMatch[2];
                    emailFound = true;
                }
            }
            
            // Pattern 2: Standard @ format
            if (!emailFound) {
                const emailRegex = /([a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/;
                const emailMatch = transcription.match(emailRegex);
                if (emailMatch) {
                    result.email = emailMatch[0];
                    emailFound = true;
                }
            }
            
            // Pattern 3: "at" format fallback
            if (!emailFound) {
                const voiceEmailRegex = /([a-zA-Z0-9._%-]+)\s+at\s+([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/i;
                const voiceEmailMatch = transcription.match(voiceEmailRegex);
                if (voiceEmailMatch) {
                    result.email = voiceEmailMatch[1] + '@' + voiceEmailMatch[2];
                }
            }

            // Extract names - improved patterns
            let nameFound = false;
            
            // Pattern 1: "first name [First], last name [Last]" - most specific
            const firstNameIsRegex = /(?:is first name|first name is|first name)\s+([A-Z][a-z]+)[,\s]*(?:last name is|last name)\s+([A-Z][a-z]+)/i;
            const firstNameIsMatch = transcription.match(firstNameIsRegex);
            if (firstNameIsMatch) {
                result.name = firstNameIsMatch[1] + ' ' + firstNameIsMatch[2];
                nameFound = true;
            }
            
            // Pattern 2: "first named [First], last name [Last]"
            if (!nameFound) {
                const firstNamedRegex = /(?:is first named|first named)\s+([A-Z][a-z]+),?\s*(?:last name\s+)?([A-Z][a-z]+)/i;
                const firstNamedMatch = transcription.match(firstNamedRegex);
                if (firstNamedMatch) {
                    result.name = firstNamedMatch[1] + ' ' + firstNamedMatch[2];
                    nameFound = true;
                }
            }
            
            // Pattern 2: "client's name is [First], last name [Last]"
            if (!nameFound) {
                const clientNameRegex = /(?:client's name is|name is)\s+([A-Z][a-z]+),?\s*(?:last name\s+)?([A-Z][a-z]+)/i;
                const clientNameMatch = transcription.match(clientNameRegex);
                if (clientNameMatch) {
                    result.name = clientNameMatch[1] + ' ' + clientNameMatch[2];
                    nameFound = true;
                }
            }
            
            // Pattern 2: "first name [First], last name [Last]"
            if (!nameFound) {
                const firstLastRegex = /(?:first name|first)\s+([A-Z][a-z]+)(?:.*?(?:last name|last)\s+([A-Z][a-z]+))?/i;
                const firstLastMatch = transcription.match(firstLastRegex);
                if (firstLastMatch) {
                    const firstName = firstLastMatch[1];
                    const lastName = firstLastMatch[2] || '';
                    result.name = lastName ? firstName + ' ' + lastName : firstName;
                    nameFound = true;
                }
            }
            
            // Pattern 3: "name is [Full Name]"
            if (!nameFound) {
                const nameRegex = /(?:name is|I'm|my name is|this is)\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)/i;
                const nameMatch = transcription.match(nameRegex);
                if (nameMatch) {
                    result.name = nameMatch[1];
                    nameFound = true;
                }
            }
            
            // Pattern 4: Fallback - first capitalized words
            if (!nameFound) {
                const firstWordsRegex = /^([A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)/;
                const firstWordsMatch = transcription.match(firstWordsRegex);
                if (firstWordsMatch) {
                    result.name = firstWordsMatch[1];
                }
            }

            // Extract company - improved patterns with better specificity
            let companyFound = false;
            
            // Pattern 1: "company's name is [Company]" - most direct for current format
            const companyNameIsDirectRegex = /company's name is ([A-Z][a-zA-Z\s&.,-]*(?:Solutions|Business|Services|Company|Inc|LLC|Corp))/i;
            const companyNameIsDirectMatch = transcription.match(companyNameIsDirectRegex);
            if (companyNameIsDirectMatch) {
                result.company = companyNameIsDirectMatch[1].trim();
                companyFound = true;
            }
            
            // Pattern 2: "president of the business named [Company]" - fallback
            if (!companyFound) {
                const presidentBusinessNamedRegex = /(?:he is the president of|president of)\s+the business named\s+([A-Z][a-zA-Z\s&.,-]*(?:Solutions|Business|Services|Company|Inc|LLC|Corp))[.\s]*(?:please|phone|email|so|$)/i;
                const presidentBusinessNamedMatch = transcription.match(presidentBusinessNamedRegex);
                if (presidentBusinessNamedMatch) {
                    result.company = presidentBusinessNamedMatch[1].trim();
                    companyFound = true;
                }
            }
            
            // Pattern 1b: "he's the president of [Company]" - fallback
            if (!companyFound) {
                const presidentOfRegex = /(?:he's the president of|president of)\s+([A-Z][a-zA-Z\s&.,-]*(?:Solutions|Business|Services|Company|Inc|LLC|Corp))[.\s]*(?:please|phone|email|so|$)/i;
                const presidentOfMatch = transcription.match(presidentOfRegex);
                if (presidentOfMatch) {
                    result.company = presidentOfMatch[1].trim();
                    companyFound = true;
                }
            }
            
            // Pattern 2: "his company's [company]" - handle possessive form
            if (!companyFound) {
                const companyPossessiveRegex = /his company's ([a-z\s]+(?:solutions|business|services|company|inc|llc|corp))/i;
                const companyPossessiveMatch = transcription.match(companyPossessiveRegex);
                if (companyPossessiveMatch) {
                    // Convert to proper case
                    const companyName = companyPossessiveMatch[1]
                        .split(' ')
                        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                        .join(' ');
                    result.company = companyName.trim();
                    companyFound = true;
                }
            }
            
            // Pattern 3: "company is [Company]" - simple and direct
            if (!companyFound) {
                const companyIsRegex = /company is (Total Success Business Solutions)/i;
                const companyIsMatch = transcription.match(companyIsRegex);
                if (companyIsMatch) {
                    result.company = companyIsMatch[1].trim();
                    companyFound = true;
                }
            }
            
            // Pattern 2: "company name is [Company]" - capture full company name including "Solutions"
            if (!companyFound) {
                const companyNameIsRegex = /(?:his company name is|company name is)\s+([A-Z][a-zA-Z\s&.,-]*(?:Solutions|Business|Services|Company|Inc|LLC|Corp))[,\s]*(?:please|phone|email|cell|and|$)/i;
                const companyNameIsMatch = transcription.match(companyNameIsRegex);
                if (companyNameIsMatch) {
                    result.company = companyNameIsMatch[1].trim();
                    companyFound = true;
                }
            }
            
            // Pattern 2: "business is [Company]"
            if (!companyFound) {
                const businessIsRegex = /(?:his business is|business is)\s+([A-Z][a-zA-Z\s&.,-]+?)(?:\.\s+|[,\s]*(?:please|phone|email|his|her|cell|so|and|$))/i;
                const businessIsMatch = transcription.match(businessIsRegex);
                if (businessIsMatch) {
                    result.company = businessIsMatch[1].trim();
                    companyFound = true;
                }
            }
            
            // Pattern 3: "with [Company]", "at [Company]" or "president of [Company]"
            if (!companyFound) {
                const withCompanyRegex = /(?:he's with|with|at|president of|CEO of|owner of)\s+([A-Z][a-zA-Z\s&.,-]+?)(?:\.\s+|[,\s]*(?:please|phone|email|his|her|cell|so|and|$))/i;
                const withCompanyMatch = transcription.match(withCompanyRegex);
                if (withCompanyMatch) {
                    result.company = withCompanyMatch[1].trim();
                    companyFound = true;
                }
            }
            
            // Pattern 4: "company name" explicit
            if (!companyFound) {
                const companyNameRegex = /company name[,\s]+([A-Z][a-zA-Z\s&.,-]+?)(?:[,\s]*(?:please|phone|email|$))/i;
                const companyNameMatch = transcription.match(companyNameRegex);
                if (companyNameMatch) {
                    result.company = companyNameMatch[1].trim();
                    companyFound = true;
                }
            }
            
            // Pattern 3: "from|at|with|work for"
            if (!companyFound) {
                const companyRegex = /(?:from|at|with|work for|work at)\s+([A-Z][a-zA-Z\s&.,-]+(?:Inc|LLC|Corp|Company|Co\.|Ltd|Solutions|Business)?)/i;
                const companyMatch = transcription.match(companyRegex);
                if (companyMatch) {
                    result.company = companyMatch[1].trim();
                    companyFound = true;
                }
            }
            
            // Pattern 4: Look for "Solutions", "Business", etc.
            if (!companyFound) {
                const businessRegex = /([A-Z][a-zA-Z\s]+(?:Solutions|Business|Services|Company|Inc|LLC|Corp))/;
                const businessMatch = transcription.match(businessRegex);
                if (businessMatch) {
                    result.company = businessMatch[1].trim();
                }
            }

            return result;
        }
        
        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            hideElement('success');
        }
        
        function showSuccess(message) {
            const successDiv = document.getElementById('success');
            successDiv.textContent = message;
            successDiv.style.display = 'block';
            hideElement('error');
        }
        
        function hideElement(id) {
            document.getElementById(id).style.display = 'none';
        }
        
        function showTranscription(text) {
            const div = document.getElementById('transcriptionResult');
            div.innerHTML = '<h3>Transcription:</h3><p>' + text + '</p>';
            div.style.display = 'block';
        }
        
        function showContactData(data) {
            const div = document.getElementById('contactData');
            div.innerHTML = 
                '<h3>Extracted Contact Info:</h3>' +
                '<p><strong>Name:</strong> ' + (data.name || 'Not detected') + '</p>' +
                '<p><strong>Phone:</strong> ' + (data.phone || 'Not detected') + '</p>' +
                '<p><strong>Email:</strong> ' + (data.email || 'Not detected') + '</p>' +
                (data.company ? '<p><strong>Company:</strong> ' + data.company + '</p>' : '');
            div.style.display = 'block';
        }
    </script>
</body>
</html>